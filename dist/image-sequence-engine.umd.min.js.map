{"version":3,"file":"image-sequence-engine.umd.min.js","sources":["../src/ImageSequenceEngine.js"],"sourcesContent":["class ImageSequenceEngine {\n  constructor(options = {}) {\n    this.options = {\n      container: null,\n      imageUrls: [],\n      initialLoadComplete: false,\n      onError: (error) => console.error(error),\n      ...options\n    };\n\n    if (!this.options.container) {\n      throw new Error('Container element is required');\n    }\n\n    if (!Array.isArray(this.options.imageUrls) || this.options.imageUrls.length === 0) {\n      throw new Error('Image URLs array is required and must not be empty');\n    }\n\n    this.totalFrames = this.options.imageUrls.length;\n    this.images = new Map();\n    this.loadingPromises = new Map();\n    this.currentFrame = 0;\n    this.isScrollLocked = true;\n    this.progress = 0;\n\n    this.init();\n  }\n\n  init() {\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    this.options.container.appendChild(this.canvas);\n\n    this.setupCanvas();\n    this.startInitialLoading();\n  }\n\n  setupCanvas() {\n    const updateSize = () => {\n      const rect = this.options.container.getBoundingClientRect();\n      const dpr = window.devicePixelRatio || 1;\n\n      this.canvas.width = rect.width * dpr;\n      this.canvas.height = rect.height * dpr;\n      this.canvas.style.width = `${rect.width}px`;\n      this.canvas.style.height = `${rect.height}px`;\n\n      this.ctx.scale(dpr, dpr);\n    };\n\n    updateSize();\n    window.addEventListener('resize', updateSize);\n  }\n\n  async startInitialLoading() {\n    try {\n      // Carica sempre il primo frame\n      await this.loadImage(this.options.imageUrls[0]);\n\n      // Carica 1 frame ogni 8 (8, 16, 24, ...)\n      const initialFrames = [0].concat(\n        Array.from({ length: Math.floor(this.totalFrames / 8) },\n          (_, i) => (i + 1) * 8)\n      );\n\n      await this.loadFrames(initialFrames);\n\n      this.unlockScroll();\n      this.startSecondaryLoading();\n    } catch (error) {\n      this.options.onError(error);\n    }\n  }\n\n  loadImage(url) {\n    if (!url) {\n      return Promise.reject(new Error('Invalid image URL'));\n    }\n\n    if (this.loadingPromises.has(url)) {\n      return this.loadingPromises.get(url);\n    }\n\n    if (this.images.has(url)) {\n      return Promise.resolve(this.images.get(url));\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      const img = new Image();\n\n      img.onload = () => {\n        this.images.set(url, img);\n        this.loadingPromises.delete(url);\n        this.emit('imageLoaded', {\n          url,\n          loaded: this.images.size,\n          total: this.totalFrames\n        });\n        resolve(img);\n      };\n\n      img.onerror = () => {\n        this.loadingPromises.delete(url);\n        const error = new Error(`Failed to load image: ${url}`);\n        this.options.onError(error);\n        reject(error);\n      };\n\n      img.src = url;\n    });\n\n    this.loadingPromises.set(url, promise);\n    return promise;\n  }\n\n  setupCanvas() {\n    const updateSize = () => {\n      const rect = this.options.container.getBoundingClientRect();\n      const dpr = window.devicePixelRatio || 1;\n\n      this.canvas.width = rect.width * dpr;\n      this.canvas.height = rect.height * dpr;\n      this.canvas.style.width = `${rect.width}px`;\n      this.canvas.style.height = `${rect.height}px`;\n\n      this.ctx.scale(dpr, dpr);\n    };\n\n    updateSize();\n    window.addEventListener('resize', updateSize);\n  }\n\n  async startSecondaryLoading() {\n    // Carica i frame intermedi (4, 12, 20, ...)\n    const secondaryFrames = Array.from(\n      { length: Math.floor(this.totalFrames / 4) },\n      (_, i) => (i + 1) * 4\n    ).filter(frame => !this.images.has(this.options.imageUrls[frame]));\n\n    // Avvia il caricamento dei frame secondari\n    this.loadFrames(secondaryFrames).then(() => {\n      // Dopo i frame secondari, carica tutti i rimanenti in sequenza\n      const remainingFrames = Array.from(\n        { length: this.totalFrames },\n        (_, i) => i\n      ).filter(frame => !this.images.has(this.options.imageUrls[frame]));\n\n      this.loadFrames(remainingFrames);\n    });\n  }\n\n  unlockScroll() {\n    this.isScrollLocked = false;\n    this.setupScrollListener();\n    this.emit('readyToScroll');\n  }\n\n  setupScrollListener() {\n    const calculateProgress = () => {\n      const rect = this.options.container.getBoundingClientRect();\n      const scrollHeight = this.options.container.scrollHeight - window.innerHeight;\n      const scrollDistance = window.scrollY - rect.top;\n\n      this.progress = Math.max(0, Math.min(1, scrollDistance / scrollHeight));\n      this.render();\n    };\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          window.addEventListener('scroll', calculateProgress);\n        } else {\n          window.removeEventListener('scroll', calculateProgress);\n        }\n      });\n    });\n\n    observer.observe(this.options.container);\n  }\n\n  async loadFrames(frameIndices) {\n    const promises = frameIndices.map(index => {\n      const url = this.options.imageUrls[index];\n      return this.loadImage(url);\n    });\n\n    await Promise.all(promises);\n    this.emit('batchLoaded', {\n      loaded: this.images.size,\n      total: this.totalFrames\n    });\n  }\n\n  render() {\n    if (this.isScrollLocked) return;\n\n    const frameIndex = Math.floor(this.progress * (this.totalFrames - 1));\n    const imageUrl = this.options.imageUrls[frameIndex];\n    const image = this.images.get(imageUrl);\n\n    if (image && frameIndex !== this.currentFrame) {\n      this.currentFrame = frameIndex;\n      this.drawImage(image);\n    }\n  }\n\n  drawImage(image) {\n    const canvas = this.canvas;\n    const ctx = this.ctx;\n    const containerRect = this.options.container.getBoundingClientRect();\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    const containerRatio = containerRect.width / containerRect.height;\n    const imageRatio = image.width / image.height;\n\n    let drawWidth = containerRect.width;\n    let drawHeight = containerRect.height;\n\n    if (containerRatio > imageRatio) {\n      drawHeight = drawWidth / imageRatio;\n    } else {\n      drawWidth = drawHeight * imageRatio;\n    }\n\n    const x = (containerRect.width - drawWidth) / 2;\n    const y = (containerRect.height - drawHeight) / 2;\n\n    ctx.drawImage(image, x, y, drawWidth, drawHeight);\n  }\n\n  emit(event, data) {\n    const eventName = `imageSequence:${event}`;\n    const customEvent = new CustomEvent(eventName, { detail: data });\n    this.options.container.dispatchEvent(customEvent);\n  }\n\n  getLoadingProgress() {\n    return {\n      loaded: this.images.size,\n      total: this.totalFrames,\n      percentage: (this.images.size / this.totalFrames) * 100\n    };\n  }\n\n  destroy() {\n    this.canvas.remove();\n    this.images.clear();\n    this.loadingPromises.clear();\n  }\n}\n\nexport default ImageSequenceEngine;\nexport { ImageSequenceEngine };"],"names":["constructor","options","this","container","imageUrls","initialLoadComplete","onError","error","console","Error","Array","isArray","length","totalFrames","images","Map","loadingPromises","currentFrame","isScrollLocked","progress","init","canvas","document","createElement","ctx","getContext","appendChild","setupCanvas","startInitialLoading","updateSize","rect","getBoundingClientRect","dpr","window","devicePixelRatio","width","height","style","scale","addEventListener","loadImage","initialFrames","concat","from","Math","floor","_","i","loadFrames","unlockScroll","startSecondaryLoading","url","Promise","reject","has","get","resolve","promise","img","Image","onload","set","delete","emit","loaded","size","total","onerror","src","secondaryFrames","filter","frame","then","remainingFrames","setupScrollListener","calculateProgress","scrollHeight","innerHeight","scrollDistance","scrollY","top","max","min","render","IntersectionObserver","entries","forEach","entry","isIntersecting","removeEventListener","observe","frameIndices","promises","map","index","all","frameIndex","imageUrl","image","drawImage","containerRect","clearRect","containerRatio","imageRatio","drawWidth","drawHeight","x","y","event","data","customEvent","CustomEvent","detail","dispatchEvent","getLoadingProgress","percentage","destroy","remove","clear"],"mappings":"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"}